{"version":3,"sources":["masked-input/masked-input.jsx"],"names":["IS_IE9_10","window","ActiveXObject","IS_ANDROID","test","navigator","userAgent","IS_IE11","Object","hasOwnProperty","call","operationType","ADD","DELETE","REPLACE","MaskedInput","value","beforeInputSelection","start","end","setMask","props","mask","formatCharacters","format","nextProps","reformatValue","caretFixTimeout","clearTimeout","length","maxLength","undefined","onProcessInputEvent","ref","input","handleBeforeInput","handleInput","handleChange","event","selectionStart","selectionEnd","onBeforeInput","processInputEvent","onInput","onChange","focus","blur","newMask","maskPattern","prevSelection","newValue","target","currentValue","formattedValue","newSelection","opType","beforeInputSelectionLength","index","isEditableIndex","setInputSelection","clampSelection","setInputSelectionByTimeout","selection","firstEditableIndex","lastEditableIndex","setTimeout","Component","propTypes","string","isRequired","objectOf","shape","validate","func","transform","number"],"mappings":"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","file":"masked-input.js","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint react/prop-types: 0 */\n\nimport { autobind } from 'core-decorators';\nimport React from 'react';\nimport Type from 'prop-types';\n\nimport Mask from './mask';\n\n// В эту проверку попадают IE9 и IE10, которые не могут корректно работать с кареткой на событии `input`.\nconst IS_IE9_10 = typeof window !== 'undefined' && !!window.ActiveXObject;\n\nconst IS_ANDROID = typeof window !== 'undefined' && /(android)/i.test(window.navigator.userAgent);\n\n// Для IE11 вместо `onChange`, используем событие `onInput`, для правильной работы copy/paste\n// Issue на ошибку в React: https://github.com/facebook/react/issues/7211\n// Детектим IE11: `Object.hasOwnProperty.call(window, 'ActiveXObject') && !window.ActiveXObject;`\nconst IS_IE11 = typeof window !== 'undefined'\n    && Object.hasOwnProperty.call(window, 'ActiveXObject')\n    && !window.ActiveXObject;\n\n// Типы операции, которые пользователь может производить с текстовым полем.\nconst operationType = {\n    ADD: 0,\n    DELETE: 1,\n    REPLACE: 2\n};\n\n/**\n * Компонент поля ввода с поддержкой масок.\n * Расширяет стандратный <input /> React-а.\n */\nclass MaskedInput extends React.Component {\n    static propTypes = {\n        /** Маска для поля ввода, использует формат https://github.com/insin/inputmask-core */\n        mask: Type.string.isRequired,\n        /** Кастомные форматтеры символов маски, использует формат formatCharacters из `inputmask-core` */\n        formatCharacters: Type.objectOf(\n            Type.shape({\n                validate: Type.func.isRequired,\n                transform: Type.func\n            })\n        ),\n        /** Максимальное число символов */\n        maxLength: Type.number,\n        /** Обработчик, вызываемый перед началом ввода в поле */\n        onProcessInputEvent: Type.func\n    };\n\n    /**\n     * @type {HTMLInputElement}\n     */\n    input;\n\n    /**\n     * @type {String}\n     */\n    maskPattern;\n\n    /**\n     * @type {Mask}\n     */\n    mask;\n\n    /**\n     * @type {FormatCharacters}\n     */\n    formatCharacters;\n\n    /**\n     * @type {String}\n     */\n    value = '';\n\n    /**\n     * @type {Number}\n     */\n    caretFixTimeout;\n\n    /**\n     * @type {{ start: Number, end: Number }}\n     */\n    beforeInputSelection = { start: 0, end: 0 };\n\n    componentWillMount() {\n        this.setMask(this.props.mask, this.props.formatCharacters);\n        this.value = this.mask.format(this.props.value || '');\n    }\n\n    componentWillReceiveProps(nextProps) {\n        let reformatValue = false;\n\n        if (this.props.mask !== nextProps.mask || this.props.formatCharacters !== nextProps.formatCharacters) {\n            this.setMask(nextProps.mask, nextProps.formatCharacters);\n            reformatValue = true;\n        }\n\n        if (reformatValue || this.props.value !== nextProps.value) {\n            this.value = this.mask.format(nextProps.value || '');\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.caretFixTimeout) {\n            clearTimeout(this.caretFixTimeout);\n            this.caretFixTimeout = null;\n        }\n    }\n\n    render() {\n        let props = { ...this.props };\n        let length = props.maxLength !== undefined ? props.maxLength : this.mask.length;\n\n        delete props.mask;\n        delete props.formatCharacters;\n        delete props.onProcessInputEvent;\n\n        return (\n            <input\n                { ...props }\n                ref={ (ref) => { this.input = ref; } }\n                maxLength={ length }\n                value={ this.value }\n                onBeforeInput={ this.handleBeforeInput }\n                onInput={ this.handleInput }\n                onChange={ this.handleChange }\n            />\n        );\n    }\n\n    @autobind\n    handleBeforeInput(event) {\n        this.beforeInputSelection = {\n            start: this.input.selectionStart,\n            end: this.input.selectionEnd\n        };\n\n        if (this.props.onBeforeInput) {\n            this.props.onBeforeInput(event);\n        }\n    }\n\n    @autobind\n    handleInput(event) {\n        if (!IS_IE9_10) {\n            event = this.processInputEvent(event);\n        }\n\n        if (this.props.onInput) {\n            this.props.onInput(event);\n        }\n\n        if (IS_IE11) {\n            if (this.props.onChange) {\n                this.props.onChange(event);\n            }\n        }\n    }\n\n    @autobind\n    handleChange(event) {\n        if (IS_IE9_10) {\n            event = this.processInputEvent(event);\n        }\n\n        if (!IS_IE11) {\n            if (this.props.onChange) {\n                this.props.onChange(event);\n            }\n        }\n    }\n\n    /**\n     * Устанавливает фокус на поле ввода.\n     *\n     * @public\n     */\n    focus() {\n        this.input.focus();\n    }\n\n    /**\n     * Снимает фокус с поля ввода.\n     *\n     * @public\n     */\n    blur() {\n        this.input.blur();\n    }\n\n    /**\n     * Возвращает ссылку на HTMLElement инпута.\n     *\n     * @public\n     * @returns {HTMLInputElement}\n     */\n    getControl() {\n        return this.input;\n    }\n\n    /**\n     * Синхронно обновляет маску на поле ввода.\n     *\n     * @public\n     * @param {String} newMask Новая маска\n     * @param {FormatCharacters} [formatCharacters] Форматтер маски\n     */\n    setMask(newMask, formatCharacters) {\n        if (this.maskPattern !== newMask || this.formatCharacters !== formatCharacters) {\n            this.mask = new Mask(newMask, formatCharacters);\n            this.maskPattern = newMask;\n            this.formatCharacters = formatCharacters;\n        }\n    }\n\n    processInputEvent(event) {\n        if (this.props.onProcessInputEvent) {\n            this.props.onProcessInputEvent(event);\n        }\n\n        let prevSelection = this.input.selectionStart;\n        let newValue = event.target.value;\n\n        let currentValue = this.value;\n        let formattedValue = this.mask.format(newValue);\n        this.value = formattedValue;\n        event.target.value = formattedValue;\n\n        // Если изменение поля ввода произошло не в конце ввода,\n        // то необходимо починить стандартное поведение Реакта и\n        // вернуть каретку к последнему изменению.\n        if (prevSelection <= currentValue.length) {\n            let newSelection = prevSelection;\n\n            // Определяем тип операции, который был произведен над текстовым полем.\n            let opType = newValue.length >= currentValue.length\n                ? operationType.ADD\n                : operationType.DELETE;\n\n            // На пользовательском инпуте было выделение перед операцией,\n            // значит могла быть операция или удаления или замены.\n            let beforeInputSelectionLength = this.beforeInputSelection.end - this.beforeInputSelection.start;\n            if (beforeInputSelectionLength >= 1) {\n                if (newValue.length !== currentValue.length - beforeInputSelectionLength) {\n                    opType = operationType.REPLACE;\n                }\n            }\n\n            // Для операции доавления и замены, если мы стояли на нередактируемом символе,\n            // то добаляем сдвиг до ближайшего редактируемого.\n            if (opType === operationType.ADD || opType === operationType.REPLACE) {\n                let index = this.beforeInputSelection.start;\n                while (!this.mask.isEditableIndex(index) && index < formattedValue.length) {\n                    index += 1;\n                }\n                newSelection += (index - this.beforeInputSelection.start);\n            }\n\n            // Если вдруг попали на нередактируемый символ маски,\n            // то подвигаем курсом до ближайшего редактируемого.\n            if (opType === operationType.ADD || opType === operationType.REPLACE) {\n                while (!this.mask.isEditableIndex(newSelection) && newSelection < formattedValue.length) {\n                    newSelection += 1;\n                }\n            } else if (opType === operationType.DELETE) {\n                while (!this.mask.isEditableIndex(newSelection - 1) && newSelection > 0) {\n                    newSelection -= 1;\n                }\n            }\n\n            this.setInputSelection(this.clampSelection(newSelection));\n        // Если изменение поля произошло в конце ввода.\n        // Android chrome имеет дефект с автоматической установкой каретки\n        // при использовании клавиатуры отличной от type=\"text\".\n        } else if (IS_ANDROID) {\n            this.setInputSelectionByTimeout(event.target.selectionStart);\n        }\n\n        return event;\n    }\n\n    /**\n     * Возвращает положение каретки с учетом первого и последнего редактируемого символа маски.\n     *\n     * @param {Number} selection Положение каретки\n     * @returns {Number}\n     */\n    clampSelection(selection) {\n        if (selection < this.mask.firstEditableIndex) {\n            return this.mask.firstEditableIndex;\n        }\n\n        // +1 разрешает каретке становится в конец поля ввода при необходимости.\n        if (selection > this.mask.lastEditableIndex + 1) {\n            return this.mask.lastEditableIndex + 1;\n        }\n\n        return selection;\n    }\n\n    /**\n     * Устанавливает каретку поля ввода в новую позицию.\n     *\n     * @param {Number} selection Новое положение каретки\n     */\n    setInputSelection(selection) {\n        this.input.selectionStart = selection;\n        this.input.selectionEnd = selection;\n\n        // IE10 не умеет синхронно в событие `change` переставлять каретку.\n        // Android chrome имеет дефект с автоматической установкой каретки\n        // при использовании клавиатуры отличной от type=\"text\".\n        if (IS_IE9_10 || IS_ANDROID) {\n            this.setInputSelectionByTimeout(selection);\n        }\n    }\n\n    /**\n     * Устанавливает каретку поля ввода в заданную позицию асинхронно.\n     *\n     * Во-избежание дефекта с установкой каретки, наблюдаемом в мобильных браузерах, а так же\n     * браузерах IE9-10, установка происходит асинхронно, с минимальной задержкой,\n     * с помощью [setTimeout] обертки.\n     *\n     * @param {Number} selection Положение каретки\n     */\n    setInputSelectionByTimeout(selection) {\n        if (this.caretFixTimeout) {\n            clearTimeout(this.caretFixTimeout);\n            this.caretFixTimeout = null;\n        }\n\n        this.caretFixTimeout = setTimeout(() => {\n            this.caretFixTimeout = null;\n            this.input.selectionStart = selection;\n            this.input.selectionEnd = selection;\n        }, 0);\n    }\n}\n\nexport default MaskedInput;\n"]}